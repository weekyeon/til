# 클래스

### 목차

* 객체지향 프로그래밍(OOP)
* 클래스
* 구성요소(필드, 생성자, 메소드)
* this
* static
* final 필드
* 상수(static final)
* 접근제한자
* Getter & Setter



### 객체지향 프로그래밍

* Object Oriented Programming, OOP
* 소프트웨어 개발 시 부품에 해당하는 객체를 먼저 만들고, 각 객체를 하나씩 조립해서 완성된 프로그램을 만드는 기법
* 객체
  * 속성과 기능을 가지는 프로그램 단위
  * **Java에서는 속성이 필드, 기능(동작)이 메소드**
  * 객체는 각각 독립적으로 존재
  * 객체는 다른 객체와 상호작용하면서 동작(객체 간의 협력)
  * **메소드** : 객체들 사이의 상호작용 수단
  * **메소드 호출** : 객체가 다른 객체의 기능을 이용
* 특징
  * 캡슐화
    * **객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 감추는 것**
    * 외부 객체는 객체 내부의 구조를 알지 못함
    * 객체가 노출하여 제공하는 필드와 메소드만 이용 가능
    * **외부의 잘못된 사용으로 인해 객체 손상 방지 가능**
    * 캡슐화된 객체의 노출 여부는 접근 제한자를 사용하여 설정
  * 상속
    * 상위 객체는 자신의 필드와 메소드를 하위 객체에게 상속하여 하위 객체가 사용 가능하도록 함
    * 상위 객체 재사용으로 인해 하위 객체를 쉽고 빠르게 설계 가능
    * 이미 잘 개발된 객체를 재사용하여 새로운 객체를 만들기 때문에 코드 중복 감소
    * 개발 시간 절약
    * 유지보수 시간 최소화
  * 다형성
    * **같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질**
    * 하나의 타입에 여러 객체를 대입하여 다양한 기능 이용 가능
    * 객체의 부품화 가능



### 클래스

* 객체를 생성하기 위한 설계도

* 객체를 생성하기 위한 필드와 메소드를 정의

* 하나의 클래스로부터 여러 개의 인스턴스 생성 가능

  * 인스턴스(instance) : 클래스로부터 만들어진 객체
  * 인스턴스화 : 클래스로부터 객체를 만드는 과정

  ![객체 생성](https://github.com/weekyeon/TIL/Java/img/java-class-img1.png)

* 구성요소

```java
public class ClassName{
    //필드 : 객체 데이터 저장
    String str;
    int num;
    
    ClassName(){
        //생성자 : 객체 생성 시 초기화
    }
    
    void methodName(){
        //메소드 : 객체 동작
    }
}
```



### 클래스 구성요소 1. 필드

* 객체의 고유 데이터, 부품 객체, 상태 정보 저장

* 선언 형태는 변수와 비슷하지만, **필드와 변수는 엄연히 다름**

  * **변수** : 생성자와 메소드 **내에서만 사용**, 생성자와 메소드 실행 종료 시 **자동 소멸**
  * **필드** : 생성자와 메소드 **전체에서 사용**, 객체가 소멸되지 않는 한 **객체와 함께 존재**

* 필드 초기값은 필드 선언 시 주어질 수도 있고 생략될 수도 있음

* 초기값이 지정되지 않은 필드는 객체 생성 시 자동으로 기본 초기값 설정

* **필드를 사용한다**는 것은 **필드 값을 읽고, 변경하는 작업**

  * 클래스 **내부**에서 사용 : 단순히 필드 이름으로 읽기/수정 가능
  * 클래스 **외부**에서 사용 : 클래스로부터 객체 생성 후 필드 사용 가능

  > 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않는다.



### 클래스 구성요소 2. 생성자

* new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출
* 호출될 때 생성자는 **객체 초기화 담당**
  * **객체 초기화** : 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것
* 생성자를 실행시키지 않고는 클래스로부터 객체 생성 불가
* 작동 순서
  1. new 연산자에 의해 생성자가 성공적으로 실행됨
  2. 힙(heap) 영역에 객체 생성
  3. 객체 주소 리턴
  4. 클래스 타입 변수에 저장
  5. 객체에 접근할 때 이용
* 생성자가 성공적으로 실행되지 않고 오류 발생 시 객체 생성 X
* 기본 생성자
  * 모든 클래스는 생성자가 반드시 존재하며 하나 이상 가질 수 있음
  * 클래스 내부에 생성자 선언 생략 시 컴파일러가 기본 생성자 자동 추가
  * 기본 생성자의 접근제한자는 클래스의 접근제한자를 따름
* 생성자 선언
  * 생성자는 리턴 타입이 없고 클래스 이름과 동일
  * 생성자 블록 내부에 객체 초기화 코드 작성
    * 일반적으로 필드에 초기값 저장, 또는 메소드 호출하여 객체 사용 전에 필요한 준비 실행
  * 매개 변수 선언은 여러 개를 선언하거나 생략 가능
  * 매개 변수는 new 연산자로 생성자 호출 시 외부 값을 생성자 블록 내부로 전달
  * 클래스에 생성자가 명시적 선언된 경우 반드시 선언된 생성자 호출하여 객체 생성
* 필드 초기화
  * 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정됨
  * 기본 초기값이 아닌 다른 값으로 초기화하는 방법
    1. 필드 선언 시 초기값 설정
       * 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 가짐
       * 객체 생성 후 변경할 수 있지만, 객체 생성 시점에는 필드값이 모두 동일
    2. 생성자에서 초기값 설정
       * 객체 생성 시점에 외부에서 제공되는 다양한 값으로 초기화돼야 한다면 생성자에서 초기화
* 생성자 오버로딩(Overloading)
  * 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
  * 매개 변수 타입과 개수, 선언된 순서가 동일한 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이 아님



### 클래스 구성요소 3. 메소드

* 객체의 동작

* 메소드 호출 시 중괄호 블록에 있는 모든 코드가 일괄적 실행

* 필드를 읽고 수정하거나 다른 객체를 생성하여 다양한 기능 수행

* 객체 간 데이터 전달 수단으로 사용

* 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있음

* 메소드 선언

  ![메소드 선언](https://github.com/weekyeon/TIL/Java/img/java-class-img2.png)

  * 리턴 타입

    * 메소드 실행 후 리턴하는 값의 타입
    * 리턴값은 있을 수도 있고, 없을 수도 있음
    * 실행 후 결과를 호출한 곳에 넘겨줄 경우 리턴값 필수
    * 리턴값이 있는 메소드는 리턴값에 알맞은 타입 필요
    * `void` : 리턴값이 없는 메소드의 리턴 타입

  * 매개 변수 선언

    * 메소드가 실행될 때 필요한 데이터를 외부로부터 받기 위해 사용
    * 매개 변수는 필요한 경우가 있고, 필요 없는 경우가 있음
    * 호출 시 넘겨주는 매개값은 반드시 매개 변수의 타입에 부합되는 값

  * 메소드 호출

    * 클래스 내/외부의 호출에 의해 실행
    * 클래스 **내부에서 호출** : 단순히 메소드명으로 호출
    * 클래스 **외부에서 호출** : 클래스로부터 객체 생성 후 참조 변수 이용해 메소드 호출

  * 리턴문

    * 리턴값이 **있는** 메소드
      * 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문(return) 사용해서 리턴값 지정
      * return문 실행 시 메소드 즉시 종료
      * 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 함
    * 리턴값이 **없는** 메소드
      * 리턴값이 없는 메소드에서도 return문 사용 가능

  * 메소드 오버로딩

    * 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
    * 메소드 오버로딩 조건 : 매개 변수 타입, 개수, 순서 중 하나가 달라야 함

    ![메소드 선언](https://github.com/weekyeon/TIL/Java/img/java-class-img3.png)



### this 키워드

* 주로 생성자와 메소드의 매개 변수 이름이 **필드와 동일**한 경우 인스턴스 멤버인 필드임을 명시할 때 사용
  * 인스턴스 멤버
    * 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드
    * 상기 필드와 메소드는 각각 인스턴스 필드, 인스턴스 메소드라 부름
    * 인스턴스 필드와 인스턴스 메소드는 객체에 소속된 멤버, 즉 객체 없이 사용 불가
* ㅇ



### static 키워드

* 정적 멤버는 클래스에 고정된 멤버로서 **객체를 생성하지 않고 사용할 수 있는 필드와 메소드**

* 클래스의 속성과 메소드에 static 키워드 사용 시 **어디서나 속성과 메소드 공유 가능**

  * 정적 멤버
    * 정적 필드와 정적 메소드는 객체(인스턴스)에 소속된 멤버가 아니라 클래스 소속 멤버
    * 클래스 멤버라고도 부름
    * 정적 멤버는 클래스 로딩이 끝나면 바로 사용할 수 있음

* 정적 멤버 선언

  * 필드

    * 인스턴스 필드 선언 : 객체마다 가지고 있어야 할 데이터
    * 정적 필드 선언 : 객체마다 가질 필요가 없는 **공용** 데이터

    ```java
    public class Calc{
        
        String color; //인스턴스 필드
        static double pi = 3.14159; //정적 필드
    
    }
    ```

  * 메소드

    * 인스턴스 메소드 선언 : 인스턴스 필드를 **이용**해서 실행해야 하는 메소드
    * 정적 메소드 선언 : 인스턴스 필드를 **이용하지 않고** 실행하는 메소드

    ```java
    public class Calc{
        
        String color;
        
        void setColor(String color){
            this.color = color;
        }
        
        static int puls(int x, int y){
            return x+y;
        }
        
        static int minus(int x, int y){
            return x-y;
        }
        
    }
    ```

* 정적 멤버 사용

  * 클래스가 메모리로 로딩되면 정적 멤버 바로 사용 가능
  * `클래스명.필드` 또는 `클래스명.메소드`

  ```java
  public class Calc{
      
      static double pi = 3.14159;
      static int plus(int x, int y){
          return x+y;
      }
      
  }
  ```

  ```java
  public class CalcEx{
      public static void main(String[] args){
          
          double rst1 = 10 * 10 * Calc.pi;
          int rst2 = Calc.plus(10, 5);
          
          System.out.println(rst1);
          System.out.println(rst2);
          
      }
  }
  ```

* 정적 초기화 블록

  * 정적 필드는 보통 선언과 동시에 초기값 설정
  * 정적 필드는 객체 생성 없이 사용해야하므로 생성자에서 초기화 작업 불가
  * Java는 정적 필드의 복잡한 초기화 작업을 위해 정적 블록(static block) 제공
    * 정적 블록
      * 클래스가 메모리로 로딩될 때 자동 실행
      * 클래스 내부에 여러 개 선언해도 무관
      * 메모리 로딩 시, 선언된 순서대로 실행
      * `static{ ... }`

* 주의할 점

  * 객체가 없어도 실행된다는 특징으로 인해 정적 메소드와 블록 내부에는 인스턴스 필드나 인스턴스 메소드 사용 불가
  * 객체 자신을 참조하는 this 키워드 사용 불가
  * 정적 메소드와 블록에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성 후 참조 변수로 접근



### final 필드

* **초기값 저장 시 그 값이 최종적인 값이 되어 프로그램 실행 도중 수정 불가한 값**
* 초기화되지 않은 final 필드를 그대로 남겨두면 컴파일 오류 발생
* 초기값 설정 방법
  * 필드 선언 시 설정 : 단순한 값일 때는 선언 시 설정하는 것이 제일 간단함
  * 생성자에서 설정 : 복잡한 초기화 코드가 필요하거나 객체 생성 시 외부 데이터로 초기화 필요할 때



### 상수(static final)

* **불변의 값을 저장하는 필드**
* 상수와 final 필드는 같지 않음
  * **상수** : 객체마다 저장할 필요가 없는 **공용성**을 지니며, 여러 가지 값으로 초기화 불가
  * **final 필드** : 객체마다 저장되며 생성자의 매개값을 통해 여러 가지 값을 가짐
* 상수는 **static이면서 final**
  * 객체마다 저장되지 않음
  * 클래스에만 포함
  * 초기값 저장 시 변경 불가
* 초기값이 단순값이라면 선언 시 주는 것이 일반적
* 복잡한 초기화가 필요할 경우 정적 블록에서 가능
* 상수 이름은 **모두 대문자**



### 접근제한자

* 라이브러리 클래스를 설계하는 바람직한 방법은 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분하여 필드, 생성자, 메소드를 설계하는 것
  * 라이브러리 클래스 : main() 메소드가 없는 대부분의 클래스로 외부 클래스에서 이용할 목적으로 설계

| 접근제한자 | 적용 대상                 | 접근 불가한 클래스                             |
| ---------- | ------------------------- | ---------------------------------------------- |
| public     | 클래스/필드/생성자/메소드 | 없음                                           |
| protected  | 필드/생성자/메소드        | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default    | 클래스/필드/생성자/메소드 | 다른 패키지에 소속된 클래스                    |
| private    | 필드/생성자/메소드        | 모든 외부 클래스                               |

* 클래스 접근제한자
  * 클래스에 적용할 수 있는 접근 제한은 **public**과 **default**
  * 클래스 선언 시 고려 사항
    * 같은 패키지 내에서 사용할 것인가?
    * 다른 패키지에서도 사용할 수 있도록 할 것인가?
  * 클래스 선언 시 public 생략하면 클래스의 접근 제한자는 default
  * public 접근제한자
    * 다른 개발자가 클래스를 사용하도록 라이브러리 클래스로 개발 시 반드시 public 접근제한자
    * 인터넷으로 배포되는 라이브러리 클래스 모두 public 접근제한자임
* 생성자 접근제한자
  * 객체 생성을 위해서는 new 연산자로 생성자를 호출해야 한다.
    * 하지만 생성자를 **어디에서나 호출할 수 있는 것은 아님**
    * 생성자가 어떤 접근제한자를 갖느냐에 따라 호출 가능 여부 결정
    * 컴파일러에 의해 자동 추가된 기본 생성자의 접근제한자는 클래스의 접근제한자와 동일
* 필드와 메소드 접근제한자
  * 필드와 메소드 선언 시 고려 사항
    * 클래스 내부에서만 사용할 것인가?
    * 패키지 내에서만 사용할 것인가?
    * 다른 패키지에서도 사용할 수 있도록 할 것인가?



### Getter & Setter



